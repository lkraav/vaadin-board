<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Commercial Vaadin Add-On License 3.0, available at http://vaadin.com/license/cval-3.
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../vaadin-element-mixin/vaadin-element-mixin.html">

<dom-module id="vaadin-board-row">
  <template>
    <style>
       :host {
        display: grid;
        display: -ms-grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr 1fr;
        --small-size: var(--vaadin-board-width-small, 600px);
        --medium-size: var(--vaadin-board-width-medium, 960px);
      }

      :host(.one-column) {
        grid-template-columns: 1fr;
        -ms-grid-columns: 1fr;
      }

      :host(.two-columns) {
        grid-template-columns: 1fr 1fr;
        -ms-grid-columns: 1fr 1fr;
      }

      :host(.three-columns) {
        grid-template-columns: 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr;
      }

      :host(.four-columns) {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        -ms-grid-columns: 1fr 1fr 1fr 1fr;
      }

       :host ::slotted(*) {
        box-sizing: border-box;
        overflow: hidden;
      }
    </style>
    <slot id="insertionPoint"></slot>
  </template>

  <script>
    (function () {
       /**
       * `<vaadin-board-row>` is a Polymer element that together with `vaadin-board` element allows to create flexible responsive layouts and build nice looking dashboard.
       *
       * Each row can contain up to four elements (fewer if colspan is used) and is automatically responsive. The row changes between `large`, `medium` and `small` modes depending on the available width and the set breakpoints. In `large` mode, typically all content is shown side-by-side, in `medium` half of the content is side by side and in `small` mode, content is laid out vertically.
       *
       * The breakpoints can be set using custom CSS properties. By default the breakpoints are `small: <600px`, `medium: < 960px`, `large >= 960px`.
       *
       *
       * ```html
       * <vaadin-board>
       *   <vaadin-board-row>
       *     <div>This could be chart 1</div>
       *     <div>This could be chart 2</div>
       *     <div>This could be chart 3</div>
       *     <div>This could be chart 4</div>
       *   </vaadin-board-row>
       * </vaadin-board>
       * ```
       *
       * ### Styling
       *
       * The following custom properties are available for styling:
       *
       * Custom property | Description | Default
       * ----------------|-------------|-------------
       * `--vaadin-board-width-small` | Determines the width where mode changes from `small` to `medium` | `600px`
       * `--vaadin-board-width-medium` | Determines the width where mode changes from `medium` to `large` | `960px`
       *
       * @memberof Vaadin
       * @mixes Vaadin.ElementMixin
       * @demo demo/index.html
       */
      class BoardRowElement extends Vaadin.ElementMixin(Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)) {
        static get is() {
          return "vaadin-board-row";
        }

        constructor() {
          super();
          this._onIronResize = this._onIronResize.bind(this);

          this._SMALL_VIEWPORT_CLASSNAME = "small";
          this._MEDIUM_VIEWPORT_CLASSNAME = "medium";
          this._LARGE_VIEWPORT_CLASSNAME = "large";

          this._oldWidth = 0;
          this._oldBreakpoints = {'smallSize': 600, 'mediumSize': 960};
        }

        ready() {
          super.ready();
          this.addEventListener('iron-resize', this._onIronResize, true);
          this.$.insertionPoint.addEventListener('slotchange', this.redraw.bind(this));
          Polymer.RenderStatus.afterNextRender(this, function () {
            //force this as an interested resizable of parent
            this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {
              node: this,
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {}
            }));
          });
        }

        connectedCallback() {
          super.connectedCallback();
          Polymer.RenderStatus.afterNextRender(this, this._onIronResize);
        }

        /**
         * Adds styles for board row based on width.
         */
        _addStyleNames(width, breakpoints) {
          if (width < breakpoints.smallSize) {
            this.classList.add(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);
          } else if (width < breakpoints.mediumSize) {
            this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.add(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.remove(this._LARGE_VIEWPORT_CLASSNAME);
          } else {
            this.classList.remove(this._SMALL_VIEWPORT_CLASSNAME);
            this.classList.remove(this._MEDIUM_VIEWPORT_CLASSNAME);
            this.classList.add(this._LARGE_VIEWPORT_CLASSNAME);
          }
        }

        _reportError() {
          const errorMessage = "The column configuration is not valid; column count should add up to 3 or 4.";
          console.warn(errorMessage, "check: \r\n" + this.outerHTML);
        }

        /**
         * Parses board-cols from DOM.
         * If there is not enough space in the row drop board cols.
         * @param {Array} array of nodes
         *
         * @return {Array} array of boardCols
         */
        _parseBoardCols(nodes) {
          const boardCols = nodes.map(node => {
            if (node.getAttribute("board-cols")) {
              return parseInt(node.getAttribute("board-cols"));
            }
            return 1;
          });

          let spaceLeft = 4;
          let returnBoardCols = [];
          nodes.forEach((node, i) => {
            spaceLeft = spaceLeft - boardCols[i];
          });

          if (spaceLeft < 0) {
            this._reportError();
            boardCols.forEach((node, i) => {
              returnBoardCols[i] = 1;
            });
          }
          else {
            returnBoardCols = boardCols.slice(0);
          }

          return returnBoardCols;
        }

        /**
         * If there is not enough space in the row.
         * Extra items are dropped from DOM.
         * @param {Array} array of board-cols for every node
         * @param {Array} array of nodes
         *
         * @return {Array} filtered array of nodes
         */
        _removeExtraNodesFromDOM(boardCols, nodes) {
          let isErrorReported = false;
          let spaceLeft = 4;
          let returnNodes = [];
          nodes.forEach((node, i) => {
            spaceLeft = spaceLeft - boardCols[i];
            if (spaceLeft < 0) {
              if (!isErrorReported) {
                isErrorReported = true;
                this._reportError();
              }
              this.removeChild(node);
            }
            else {
              returnNodes[i] = node;
            }
          });
          return returnNodes;
        }

        /**
         * Redraws the row, if necessary.
         *
         * In most cases, a board row will redraw itself if your reconfigure it. If you dynamically change CSS which affects the row, then you need to call this method.
         */
        redraw() {
          this._recalculateItemSizes(true);
        }

        _onIronResize() {
          this._recalculateItemSizes(false);
        }

        _recalculateItemSizes(forceResize) {
          const width = this.getBoundingClientRect().width;
          const breakpoints = this._measureBreakpointsInPx();
          if (forceResize || width != this._oldWidth
              || breakpoints.smallSize != this._oldBreakpoints.smallSize
              || breakpoints.mediumSize != this._oldBreakpoints.mediumSize) {
            const nodes = this.$.insertionPoint.assignedNodes({ flatten: true });
            const isElementNode = function (node) {
              return !((node.nodeType === node.TEXT_NODE)
                || (node instanceof Polymer.DomRepeat)
                || (node instanceof Polymer.DomIf));
            }

            const filteredNodes = nodes.filter(isElementNode);
            this._addStyleNames(width, breakpoints);
            const boardCols = this._parseBoardCols(filteredNodes);
            var colsInRow = boardCols.reduce((a, b) => a + b, 0);
            if (width < breakpoints.smallSize) {
                colsInRow = 1;
              } else if (width < breakpoints.mediumSize && colsInRow == 4) {
                colsInRow = 2;
              }
            this._setColumns(colsInRow);
            var spaceUsedSoFar = 0;
            this._removeExtraNodesFromDOM(boardCols, filteredNodes).forEach((e, i) => {

              var itemSize = boardCols[i];
              let nextItemSize = boardCols[i+1];
              let placesLeft = colsInRow - (spaceUsedSoFar % colsInRow);

              // an item can't take more columns than columns in a row
              if(itemSize > colsInRow){
                itemSize = colsInRow;
              }

              // If there is space on current row, but next item won't fit in, then expand the
              // current item to take the rest of the space available in current row.
              // Ie. 1-2-1 spans in two column size. second item won't fit to first row so expand
              // first item to take the full row.
              if (nextItemSize != null && itemSize < placesLeft && itemSize+nextItemSize > placesLeft) {
                itemSize = placesLeft;
              }
              // If current item is the last in the row, and there is an empty space, expand
              // it to take the whole row.
              // Ie. 1-2-1 span. Last item is empty on the last row as second row needs an own
              // row. Therefore last item should not only take first column of whole row, but
              // expand to full row.
              if (nextItemSize == null && itemSize < placesLeft){
                itemSize = placesLeft
              }

              if (itemSize > 1) {
                e.style.gridColumnEnd = "span " + itemSize;
              } else {
                e.style.gridColumnEnd = "";
              }

              // IE10, IE11 and Edge has an old, older implementation of the CSS Grid spec.
              // That spec does not include auto placement, so each item needs to have
              // column and row defined. Remove this when Edge has implemented current
              // support and we do not support IE10 / IE 11 anymore.
              e.style.msGridColumn = (spaceUsedSoFar % colsInRow)+1;
              e.style.msGridRow = Math.floor(spaceUsedSoFar / colsInRow)+1;
              if (itemSize > 1) {
                e.style.msGridColumnSpan = itemSize;
              } else {
                e.style.msGridColumnSpan = "";
              }

              //save for next iteration
              spaceUsedSoFar = spaceUsedSoFar + itemSize;
            });
            this._oldWidth = width;
            this._oldBreakpoints = breakpoints;
          }
        }

        /**
         * Measure the breakpoints in pixels.
         *
         * The breakpoints for `small` and `medium` can be given in any unit: `px`, `em`, `in` etc.
         * We need to know them in `px` so that they are comparable with the actual size.
         *
         * @return {Object} object with smallSize and mediumSize number properties, which tells
         * where the row should switch rendering size in pixels.
         */
        _measureBreakpointsInPx() {
            // Convert minWidth to px units for comparison
            const breakpoints = {};
            const tmpStyleProp = 'background-position';
            var smallSize;
            var mediumSize;
            if (window.ShadyCSS) {
              smallSize = window.ShadyCSS.getComputedStyleValue(this, '--small-size');
              mediumSize = window.ShadyCSS.getComputedStyleValue(this, '--medium-size');
            } else {
              smallSize = getComputedStyle(this).getPropertyValue('--small-size');
              mediumSize = getComputedStyle(this).getPropertyValue('--medium-size');
            }
            this.style.setProperty(tmpStyleProp, smallSize);
            breakpoints.smallSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));
            this.style.setProperty(tmpStyleProp, mediumSize);
            breakpoints.mediumSize = parseFloat(getComputedStyle(this).getPropertyValue(tmpStyleProp));
            this.style.removeProperty(tmpStyleProp);
            return breakpoints;
        }

        _setColumns(columns) {
          this.classList.remove("one-column");
          this.classList.remove("two-columns");
          this.classList.remove("three-columns");
          this.classList.remove("four-columns");
          switch (columns) {
            case 1: this.classList.add("one-column"); break;
            case 2: this.classList.add("two-columns"); break;
            case 3: this.classList.add("three-columns"); break;
            case 4:
            default: this.classList.add("four-columns"); break;
          }
        }
      }

      customElements.define(BoardRowElement.is, BoardRowElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.BoardRowElement = BoardRowElement;
    })();
  </script>
</dom-module>
